''01/17/2022''Make this a reality. Thinking about something will not manifest it.''Yes it will be ugly at first.''This combines the pwm setpoint with the speed setpoint so that anti-windup can occur.VAR {integers}  PILoop_Samples_Hz   'stating how often update() gets called allows for the loop tuning to be based off of seconds.  Motor_PWM_ref_max   'reaching this value means command PWM is saturated at 100%.  Speed_At_Full_PWM   'motor conversion factor speed command to PWM (Make it a speed reachable at 100% PWM in practice. Reduce from measured freewheel speed somewhat to include some expected load.VAR {floats}  K_Val               'Increasing this Proportional value pushes back harder and harder against error. 1.0 is unity, so one unit of error produces one unit of pushback.  P_Weight            'Optional Weighting value, leave at 1.0 for normal PID overshoot type behavior. A value like 0.5 significantly reduces initial overshoot, but only after correct tuning of K and I.  I_Val               'Increasing this value makes the Integration effect stronger, but more likely to cause oscillation. Too small and you never reach setpoint. This is technically 1/I from textbook definition.  Track_TC             'Anti-windup filter "time constant" to saturate Integrator . It is the same time unit as your process value (seconds). Higher values allow more Integrator windup (which is bad).  error_integral_f    'persists between calls to update()PUB default()  PILoop_Samples_Hz := 20       'try 5, 10, 20, 50. it should be better behaved.  Motor_PWM_ref_max := 10_000   'Full 100% on PWM.  Speed_At_Full_PWM := 160      'motor conversion factor speed command to PWM (Make it a speed reachable at 100% PWM in practice. Reduce from measured freewheel speed somewhat to include some expected load.)  K_Val := 2.5     'Increasing this Proportional value pushes back harder and harder against error. 1.0 is unity, so one unit of error produces one unit of pushback.  P_Weight := 0.55 'Optional Weighting value, leave at 1.0 for normal PID overshoot type behavior. A value like 0.5 significantly reduces initial overshoot, but only after correct tuning of K and I.  I_Val := 2.0     'Increasing this value makes the Integration effect stronger, but more likely to cause oscillation. Too small and you never reach setpoint. This is technically 1/I from textbook definition.  Track_TC := 2.0  'Anti-windup filter "time constant" to saturate Integrator . It is the same time unit as your process value (seconds). Higher values allow more Integrator windup (which is bad).  error_integral_f := 0.0PUB start(sample_freq, pwm_ref_max, speed_max_achievable)  PILoop_Samples_Hz := sample_freq  Motor_PWM_ref_max := pwm_ref_max  Speed_At_Full_PWM := speed_max_achievable  default()PUB update(target_speed_f, actual_speed_f) : command_pwm | error_speed_f, proportional_f, command_speed_f, integral_gain_f, anti_windup_f, tracking_time_f  'The PI Controller Loop calculation:  error_speed_f := target_speed_f -. actual_speed_f  'Proportional weighting because we are being fancy.  'Without weighting, you would just use "proportional_f := (K_Val *. error_speed_f)"  proportional_f := K_Val *. (P_Weight *. target_speed_f -. actual_speed_f)  command_speed_f := proportional_f +. error_integral_f  'Output limitation and anti-windup:  command_pwm := ROUND(command_speed_f) * Motor_PWM_ref_max / Speed_At_Full_PWM  if command_pwm < -Motor_PWM_ref_max    command_pwm := -Motor_PWM_ref_max    anti_windup_f := FLOAT(-Speed_At_Full_PWM)  elseif command_pwm > Motor_PWM_ref_max    command_pwm := Motor_PWM_ref_max    anti_windup_f := FLOAT(Speed_At_Full_PWM)  else    'no effect when not saturating    anti_windup_f := command_speed_f  'The goal is to make the I tuning independent of how often the loop runs.  'If the loop runs more total times a second, chop up the gains into smaller pieces.  integral_gain_f := K_Val *. I_Val /. float(PILoop_Samples_Hz)  tracking_time_f := 1.0 /. (float(PILoop_Samples_Hz) *. Track_TC)  'Integrate the error for the next loop around:  error_integral_f := error_integral_f +. error_speed_f *. integral_gain_f +. tracking_time_f *. (anti_windup_f -. command_speed_f)